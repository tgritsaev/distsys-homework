# Практика gRPC

## Мессенджер с одним чатом
В рамках практики предлагается реализовать очень простые сервер и клиент мессенджера. У сервера будет два RPC-метода: послать сообщение в чат и подключиться к чату и получать бесконечный поток сообщений из чата.

Клиент, соответственно, должен при включении открыть поток и скапливать в своём буфере пришедшие сообщения. Кроме того, через клиент мы должны уметь отправлять сообщения в чат.

Управление gRPC клиентом будет производиться через HTTP. Для этого в заготовке клиента уже реализован HTTP сервер, принимающий запросы от пользователя через HTTP-запросы. Итого проект состоит из трех компонент: gRPC-сервер (далее **сервер**), gRPC-клиент + HTTP-сервер (**клиент**), HTTP-клиент (**пользователь**). В качестве HTTP-клиента для тестирования во время разработки предлагается использовать curl.

### Шаблон решения

В папке задания предоставлены заготовки только **клиента** на Python, Python + asyncio и Golang для решения этой задачи. Только шаблон на Python в папке `client-py` является официальным и проверен для текущих условий ДЗ, остальные шаблоны остались с прошлых версий условия и местами расходятся с текущим условием. Вы все равно можете их использовать, если поправите расхождения. Вы также можете писать на любом другом языке программирования, так как тестирование происходит через HTTP и gRPC.

### Интерфейс взаимодействия пользователя с клиентом

Тесты на сервер+клиент отправляют запросы клиенту, который представляет собой HTTP сервер, поддерживающий два вида запросов:

```
POST /sendMessage
Отправляет одно сообщение в общий чат.
Body:
{
    "author": "Ivan Ivanov",
    "text": "Hey guys"
}

Response:
{
    "sendTime": "..."
}

POST /getAndFlushMessages
Возвращает буферизированные сообщения, удаляя их из буфера.
Response:
[{
    "author": "Ivan Ivanov",
    "text": "Hey guys",
    "sendTime": "..."
},{
    "author": "Petr Petrov",
    "text": "Hey Ivan",
    "sendTime": "..."
}]
```

Примеры с curl:
```
$ curl -X POST localhost:8080/sendMessage -d '{"author": "alice", "text": "hey"}'
{"sendTime":"2021-09-12T10:25:22.454093428Z"}


$ curl -X POST localhost:8080/getAndFlushMessages
[{"author":"alice","text":"hey","sendTime":"2021-09-12T10:25:22.454093428Z"},{"author":"alice","text":"hey guys","sendTime":"2021-09-12T10:25:41.296997047Z"}]
```

### Интерфейс взаимодействия с сервером
Тесты на сервер отправляют серверу два вида запросов:

```
SendMessage {"author": "alice", "text": "hey"} возвращает sendTime
GetAndFlushMessages возвращает бесконечный поток сообщений: {"author": ..., "text": ..., "sendTime": ...} {...} {...} ...
```

Примеры с grpcurl:
```
Из папки 2-practice-grpc:

# В первом окне терминала
grpcurl -proto messenger/proto/messenger.proto -plaintext localhost:51075 Messenger/GetAndFlushMessages
# Устанавливается бесконечное соединение, команда не заканчивается, пока сервер не порвёт соединение или вы не нажмёте CTRL+C в терминале

# Во втором окне терминала
grpcurl -proto messenger/proto/messenger.proto -d '{"author": "alice", "text": "hey"}' -plaintext localhost:51075 Messenger/SendMessage
```

### Компоненты задания
1. **(2 балла)** Описать gRPC интерфейс сервера в `messenger.proto`
2. **(4 балла)** Реализовать gRPC сервер мессенджера
3. **(4 балла)** Реализовать gRPC клиент и встроить его в HTTP-приложение клиента.
4. README в папке с решением с описанием структуры решения (где какой код лежит), какие именно методы реализованы на сервере и клиенте, как они устроены в паре предложений. Обязательно укажите, какие компоненты были выполнены. При отсутствии README проверка производиться не будет.

### В каком порядке делать?
1. Напишите свой `messenger.proto` в `messenger/proto/`.

Названия сервиса, методов сервиса и полей сообщений в прото файле должны называться и иметь такие же типы как в примерах, иначе тесты не пройдут. Названия сообщений в прото файле должны быть: `ClientMessage`, `SendMessageResponse`, `google.protobuf.Empty`, `ServerMessage`. Поле `sendTime` должно иметь тип `google.protobuf.Timestamp`.

Для использования `google.protobuf.Empty` и `google.protobuf.Timestamp` необходимо прописать импорты в прото файле:
```
import "google/protobuf/timestamp.proto";
import "google/protobuf/empty.proto";
```

4. Скомпилируйте прото файл с помощью `protoc` в нужный для вас язык. Для Python, из папки `2-practice-grpc`:

`python -m grpc_tools.protoc -Imessenger/proto --python_out=messenger/proto --grpc_python_out=messenger/proto messenger/proto/messenger.proto && sed -i '/^import messenger_pb2 as messenger__pb2$/c\import messenger.proto.messenger_pb2 as messenger__pb2' messenger/proto/messenger_pb2_grpc.py`

Вторая часть команды после генерации добавляет префикс пакета `messenger.proto.` к `import messenger_pb2 as messenger__pb2` в файле `messenger_pb2_grpc.py`.

3. Реализуйте сервер, соответствующий сгенерированному интерфейсу. Заготовки для сервера нет. Сервер предлагается реализовать с нуля, используя [gRPC Basics Tutorial](https://grpc.io/docs/languages/python/basics/) и примеры различных сервисов в [Гитхаб-репозитории gRPC](https://github.com/grpc/grpc/blob/master/examples) для вашего языка программирования. Тестировать и отлаживать сервер предлагается с помощью [grpcurl](https://github.com/fullstorydev/grpcurl). Примеры команд есть выше, ниже в бонусной секции про grpcurl и в тестах на сервер.

Сервер рекомендуется расположить в файле `server-py/server.py`, так как примеры команды далее будут предполагать, что сервер находится там, и вам будет удобнее их копировать.

В docker-compose файле используются переменные окружения для настройки сервера и клиентов. gRPC сервер должен запускаться по адресу `0.0.0.0:$MESSENGER_SERVER_PORT`, где `MESSENGER_SERVER_PORT` — переменная окружения, по умолчанию равная `51075`.

Удобно добавить в свой код сервера и использовать следующую функцию для конвертации времени из секунд с начала эпохи в протобафный тип `Timestamp`:
```
@staticmethod
def _get_timestamp():
    now = time.time()
    seconds = int(now)
    nanos = int((now - seconds) * 10 ** 9)
    return google.protobuf.timestamp_pb2.Timestamp(seconds=seconds, nanos=nanos)
```

Метод `GetAndFlushMessages` должен быть реализован как **бесконечный** поток сообщений. Grpc-клиент вызывает этот метод один раз при включении, и считывает сообщения из потока по мере их поступления. При поступлении нового сообщения на сервер, сервер рассылает это сообщение всем подключенным клиентам. Каждый клиент должен получать сообщения в том порядке, в котором они поступили на сервер. Если некоторое сообщение было доставлено до момента, когда клиент подключился на прослушивание сообщений через `GetAndFlushMessages`, этот клиент не должен получить это сообщение.

4. Напишите `messenger/server.dockerfile` для вашего сервера, чтобы его можно было запустить при тестировании.

5. Реализуйте gRPC клиент, который осуществляет gRPC-вызовы и соответствующим образом обрабатывает результат. Рекомендуется использовать заготовку в папке `client-py`. В заготовке уже реализован HTTP-сервер для принятия HTTP-запросов от пользователя. Вам осталось заполнить места, помеченные TODO. Также клиент можно реализовать не используя заготовку, на любом языке программирования. В таком случае обязательно используйте переменные окружения:
   - `MESSENGER_SERVER_ADDR` — адрес gRPC сервера для клиента, чтобы подключиться к серверу, есть в заготовке
   - `MESSENGER_HTTP_PORT` — порт для запуска HTTP-сервера вашего клиента, есть в заготовке

6. Поправьте или напишите свой `messenger/client.dockerfile` для вашего клиента, чтобы его можно было запустить при тестировании.

7. Проверьте локально, что ваши тесты проходят, лучше сразу в [докере](#docker). Если `docker-compose` на что-то ругается, то поправьте конфигурацию как вам необходимо.

8. Откройте Merge Request в своём приватном репозитории и дождитесь, что тесты зелёные.

### Комментарии про потоки
HTTP-сервер в grpc-клиенте однопоточный, то есть он обрабатывает не более одного запроса в каждый момент времени. Однако в grpc-клиенте необходимо создать фоновый поток, который будет скапливать сообщения от сервера. Таким образом, информация, передающаяся между ними должна быть потокобезопасной. Единственная информация, которая передаётся между ними -- это инстанс класса Postbox, уже реализованный в потокобезопасном стиле, и стаб grpc-клиента, также являющийся потокобезопасным.

Grpc-сервер должен быть реализован многопоточно, то есть мочь обрабатывать сразу несколько grpc-запросов. В туториале и репозитории с примерами достаточно примеров многопоточных серверов.


## Запуск заготовок и тестов

#### Без виртуальных окружений
```
cd 2-practice-grpc
python -m messenger.server-py.server
python -m messenger.client-py.client
MESSENGER_HTTP_PORT=8081 python -m messenger.client-py.client

cd tests
MESSENGER_TEST_SERVER_ADDR=localhost:51075 MESSENGER_TEST_CLIENT1_ADDR=localhost:8080 MESSENGER_TEST_CLIENT2_ADDR=localhost:8081 pytest -vvs .
```

#### С виртуальными окружениями - OUTDATED
Заготовка клиента на python:
```
python3 -m virtualenv messenger/client-py/env  # нужен python версии хотя бы 3.8
source messenger/client-py/env/bin/activate
pip install -r messenger/client-py/requirements.txt

MESSENGER_SERVER_ADDR=localhost:$MESSENGER_SERVER_PORT python client.py 
```

Заготовка клиента на golang:
```
cd messenger/client-go
go mod download -x

MESSENGER_SERVER_ADDR=localhost:$MESSENGER_SERVER_PORT go run main.go
```

Запуск тестов:
```
cd tests
# можно использовать общее окружение с вашим клиентом и сервером, тогда положите его в корень папки с заданием
python3 -m virtualenv env  # нужен python версии хотя бы 3.8
source env/bin/activate
pip install -r requirements.txt

MESSENGER_TEST_CLIENT1_ADDR=localhost:8080 MESSENGER_TEST_CLIENT2_ADDR=localhost:8081 pytest -vvs .
```

### Docker
Соберите все свои сервисы:
```
docker-compose build server client1 client2
```

При изменении одного из них достаточно пересобрать только его:
```
docker-compose build server
```

client1 и client2 используют один и тот же образ для запуска, поэтому при изменении клиента можно пересобрать только одного из них:
```
docker-compose build client1
```

Запустите сервер и клиентов:
```
docker-compose up -d server client1 client2
```

Сборка и запуск тестов:
```
docker-compose build tests
docker-compose run --rm tests
```

Если что-то не работает, запустите сервер и клиентов без флага `-d[etach]`, чтобы видеть все ошибки:
```
docker-compose up server client1 client2
```

## Бонус
### [grpcurl](https://github.com/fullstorydev/grpcurl) 101

Установка grpcurl:
`sudo tar -xf grpcurl_1.8.7_linux_x86_64.tar.gz -C /usr/local/bin`
`brew install grpcurl`

Выжимка из `grpcurl -help` опций, которые пригодятся в этой домашке:
```
grpcurl [flags] [address] [list|describe] [symbol]

list
   If 'list' is indicated, the symbol (if present) should be a fully-qualified
service name. If present, all methods of that service are listed. If not
present, all exposed services are listed, or all services defined in protosets.

-proto value
   The name of a proto source file. ...
-plaintext
   Use plain-text HTTP/2 when connecting to server (no TLS).
-d string
   Data for request contents. If the value is '@' then the request contents are
   read from stdin. ...
-v
   Enable verbose output.
-vv
   Enable very verbose output.
```

Уже собранные команды, которые пригодятся:

```
grpcurl -proto proto/messenger.proto -plaintext localhost:51075 list
> Messenger

grpcurl -proto proto/messenger.proto -plaintext localhost:51075 list Messenger
> Messenger.GetAndFlushMessages
> Messenger.SendMessage

grpcurl -proto proto/messenger.proto -plaintext localhost:51075 Messenger.GetAndFlushMessages
# пустой вывод, пока не будут отправлены какие-либо сообщения
> {
>   "author": "alice",
>   "text": "hello",
>   "sendTime": "2022-08-12T14:35:41.461204767Z"
> }
> {
>   "author": "alice",
>   "text": "hello again",
>   "sendTime": "2022-08-12T14:35:42.792868160Z"
> }
>...  # соединение никогда не закрывается, сообщения продолжают поступать

grpcurl -proto proto/messenger.proto -d '{"author": "alice", "text": "hello"}' -plaintext localhost:51075 Messenger.SendMessage
> "sendTime": "2022-08-12T14:35:41.461204767Z"
```

### Многопоточное программирование в Питоне 101
Как только в программе появляется больше одного потока и эти потоки начинают обращаться (неважно, на чтение или запись) к одним и тем же данным (одной и той же переменной), необходимо защищать доступ к этим переменным примитивами синхронизации. Подробности на курсе многопоточного программирования. Самый простой примитив синхронизации -- мьютекс, в питоне `threading.Lock`. Поток может захватить мьютекс, записать данные в ячейку, и отпустить мьютекс. Гарантируется, что мьютекс может быть захвачен не более чем одним потоком в каждый момент. Пример:

```
import threading

data = 5
lock = threading.Lock()

# код потока:
lock.acquire()
data = 7
lock.release()

# то же самое, с помощью context manager (синтаксический сахар для строчек выше)
# это предпочтительный вариант
with lock:
   data = 7
```

Grpc-клиент имеет два потока (main и фоновый поток, который будет поглащать). Единственные данные, которые разделяют эти потоки -- это `stub` и объект класса `PostBox`. Можно подсмотреть в документации питоновской библиотеки для grpc, что `stub` является потокобезопасным, то есть разные потоки могут вызывать любые методы у этого объекта. Класс `PostBox` тоже реализован в потокобезопасном стиле: любые обращения к переменной `self._messages` защищены локом. Поэтому при реализации клиента вам не нужно будет добавлять собственных примитивов синхронизации.

Grpc-север должен быть многопоточным. Это значит, что обработчики запросов `sendMessage`, `getAndFlushMessages` могут быть вызваны одновременно несколькими клиентами. 

Документация, которая вам точно понадобится:
https://docs.python.org/3/library/threading.html#threading.Thread
https://docs.python.org/3/library/threading.html#threading.Lock

При реализации сервера рекомендуется использовать `queue.SimpleQueue`. Эта очередь потокобезопасна по-умолчанию, то есть, чтобы достать или положить элемент, не нужно захватывать мьютекс -- он встроен в очередь. Более того, вызов метода `SimpleQueue.get` блокируется и неактивно ждет до тех пор, пока в очереди не появится новый элемент. Для этого `queue.SimpleQueue` использует внутри себя условные переменные.

https://docs.python.org/3/library/queue.html#simplequeue-objects

Заметьте, что если вы решите использовать несколько `SimpleQueue` и решите складывать их в один список из разных потоков, вам необходимо защитить сам список мьютексом.

Если вы не хотите использовать `SimpleQueue`, вы также можете использовать активное ожидание или сырые условные переменные для своей реализации.

https://docs.python.org/3/library/threading.html#condition-objects

Если у вас возникают проблемы, пишите в чат. Любые вопросы про многопоточность принимаются, так как задание на grpc, а не на многопоточность.


### tmux 101
Вы можете сделать задание без следующей информации, но с tmux это будет удобнее.

В процессе разработки и тестирования вам понадобится держать как минимум 4 открытых терминала: с сервером, двумя клиентами и окном для отправки сообщений клиентам через curl или запуска автоматических тестов.

tmux (от 'terminal multiplexor') это консольная утилита, позволяющая позволяет открыть несколько терминалов внутри одного окна. Это может быть удобнее, чем держать четыре независимых окна.

Другой популярный вид использования tmux -- это работа на удаленном сервере. Терминалы, созданные в tmux продолжают существовать в фоновом режиме, даже если вы случайно отключились от сервера. Поэтому вы можете подключить к серверу заново, подключиться к существующей сессии tmux и продолжить работу. tmux это must-have в ежедневном арсенале программиста, поэтому может быть удобно опробовать работу с tmux уже сейчас.

`sudo apt install tmux`

Полезные команды:
```
tmux - создать новую сессию с виртуальными терминалами
CTRL+B % - поделить окно пополам вертикально
CTRL+B " - поделить окно пополам горизонтально
CTRL+B arrow - навигация между окнами
CTRL+B z[oom] - открыть текущее под-окно на весь экран терминала, или вернуть его обратно
CTRL+B [ - перейти в режим скроллинга
CTRL+B ESC - выйти из режима скроллинга
CTRL+B d[etach] - выйти из tmux обратно в командную строку, при этом все запущенные программы продолжат выполняться в фоновом режиме
```

Типичный флоу для 4 окон:
```
cd 2-practice-grpc/messenger
CTRL+B " - поделили горизонтально пополам
CTRL+B % - поделили верхнее окно вертикально пополам
CTRL+B ↓ - перешли на нижнее окно
CTRL+B % - поделили нижнее окно вертикально пополам

Запустить в каждом из окон север, клиент 1, клиент 2, и использовать последнее окно для запуска тестов или curl. В последнем окне не забудьте `cd tests`.

Окно с тестами часто удобно зазумить: CTRL+B z

Чтобы проскроллить вывод от тестов: CTRL+B [, выйти из режима скроллинга: ESC.
```