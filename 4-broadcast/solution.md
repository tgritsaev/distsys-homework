*Алгоритм:*
1. У каждого сообщения будет 3 стадии относительно каждой ноды: 
0 - вершина не получила сообщение, 1 - вершина получила, но не отправила локально, 2 - вершина получила и локально отправила сообщение.
2. Полученное локально сообщение переходит в первую стадию в своей node, рассылаем всем остальным нодам наше сообщение, так же с 
сообщением передаем информацию о том, на какой стадии находится сообщение в других нодах. 
3. Для полученного по сети сообщения синкаем информацию с тем, что знает сама нода: 
обьединяем ноды на второй стадии в рамках данного сообщения, о которых знает сама нода и о которых говорится в сообщении,
выкидываем из первой стадии ноды второй стадии, аналогично обьединяем ноды на первой стадии.
Рассылаем сообщение с обновленной информацией всем нодам не на последней стадии.
4. Когда к нам приходит сообщение и после обновления стадий мы понимаем, что на 1 или 2 стадии больше половины сообщений, мы 
отправляем сообщение локально.

Простыми словамии ноды синкают информацию касательно всех сообщений и постепенно двигаются в стадиях.

Добавляем Causal Order:
1. Для каждой ноды заводим счетчик количества пришедших локально сообщений, храним максимальный номер дошедшего сообщения от
каждой вершины, храним максимальный номер отправленного локально сообщения, полученного от каждой вершины.
2. При отправке сообщения с информацией о стадиях так же отправляем информацию о максимальных номерах дошедших сообщений от 
других вершин.
3. Если вектор вида {node: max_num} отправленных сообщений на вершине не меньше вектора вида {node: max_num} полученных сообщений
в вершине, от которой мы получили сообщение, в каждой точке, то можно отправить сообщение и изменить вектор отправленных сообщений
в данной вершине.

Ну как-то так (вроде в процессе реализации возникло пару-тройку противных мелочей, которые пришлось заифать, но суть та же)

*Обьяснение:*

Ясно, что сама вершина контролирует состояние, куда продвинулось сообщение: на первую или вторую стадию. Соответственно информация
о стадии каждого сообщения будет корректной, или хотя бы сообщение не продвинется дальше (то есть сообщение с нулевой стадии на
первую, с первой стадии на вторую). Соответственно когда мы считаем количество вершин на первой и второй стадиях, это 
количество не превышает реального. Благодаря условию, что хотя бы половина вершин будет корректно работать, можем использовать 
это количество как порог для отправки сообщения локально. 
Causal order реализует механизм количества принятых сообщений и требуемого количества принятых сообщений от каждой вершины, остается
просто сравнивать вектора. 

Хак:

1. Так как всегда будет корректно работать хотя бы половина вершин, то можно отправлять сообщение не всем, а половине.
2. Так же кажется, что в моей реализации много обменов информацией добавляют новую информацию вершине, но при пересылке не дают
   новой информации остальным вершинам. Такие случаи можно проверять вложенностями множеств, и если синхронизация с вершиной не
   дает новой информации для остальных, можно не отправлять сообщения другим вершинам.