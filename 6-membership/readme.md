# Group Membership

В этой задаче вам предстоит реализовать распределенный сервис для отслеживания состава группы (group membership).

Пусть имеется распределенная система, состоящая из _N_ узлов. У каждого узла есть свой уникальный идентификатор _id_. Будем говорить, что все работающие в некоторый момент узлы системы образуют _группу_, то есть являются ее участниками. В ходе работы системы узлы могут включаться и выключаться, тем самым вступая в группу и покидая её. Таким образом, состав участников группы может изменяться со временем. Сервис, который вам надо реализовать, должен позволять узлам узнавать текущий состав группы, а также выполнять вход и выход из группы.

Помимо явного выхода из группы (например, при штатном выключении), узлы могут покидать группу из-за отказов. В нашей модели системы возможны следующие виды отказов:
- _Внезапная остановка (падение) узла_. Позднее узел может быть перезапущен (с тем же _id_) и заново подключен к группе. Работающий узел будем называть _живым_.
- _Потеря сообщений_ между некоторыми парами узлов, в обоих или только в одном направлении. В результате живые узлы могут оказаться полностью или частично отрезаны от других узлов. Отказы сети могут носить временный характер, после чего связь восстанавливается.

Ваша реализация должна обнаруживать описанные выше отказы и обрабатывать их. Для этого вам потребуется реализовать _детектор отказов_. Ваш детектор должен обладать свойством _полноты_ - если узел стал недоступным из-за отказа, то в конечном счете все участники группы признают его отказавшим. Также постарайтесь найти хороший баланс между скоростью обнаружения отказов, точностью детектора и сопутствующими накладными расходами.

Упавшие или недоступные ни с одного из остальных участников группы узлы должны автоматически исключаться из состава группы. Таким образом, в состав группы должны входить только живые узлы, способные общаться по сети (в обе стороны) с хотя бы одним другим участником группы. Если упавший узел позднее перезапускается, то он заново выполняет вход в группу под тем же _id_, после чего остальные узлы должны вернуть его в свой список участников. Если недоступный из-за отказа сети узел позднее становится доступным, то узлы должны обнаруживать это и аналогично возвращать узел в свой список. 

Не требуется обеспечивать _строгую согласованность_ списков участников между узлами. Иными словами, допустимо, если в некоторый момент времени списки участников группы на разных узлах отличаются (например, отказавший узел кое-где еще выдается как участник группы). Главное чтобы через некоторое время после отказа или его устранения, а также входа/выхода участника, состав группы стабилизировался и стал одинаковым на всех её текущих участниках. Это называется _согласованностью в конечном счёте (eventual consistency)_.

Из-за сетевых отказов система может распасться на несколько изолированных подгрупп. Такая ситуация называется _разделением сети (network partition)_. Простейшим частным случаем разделения является отключение от сети одного узла. Разделение может быть асимметричным, когда связь между частями системы отсутствует только в одну сторону. Ваша реализация должна уметь работать в условиях разделения сети, позволяя каждому живому узлу отлеживать состав участников в его подгруппе. Например, если узел оказался отключен от сети, то он будет видеть в участниках группы только себя, а остальные узлы будут видеть в группе всех кроме него. Когда сеть восстанавливается, то в конечном счёте все живые узлы должны увидеть всех в участниках группы.

Чтобы получить максимальный балл, требуется также обеспечить хорошую масштабируемость полученного решения. А именно, при увеличении числа узлов в _X_ раз накладные расходы (сетевой трафик и число передаваемых сообщений) должны увеличиваться не более чем в _2X_ раз.  В тестах не учитываются начальные расходы на первоначальную сборку группы, только расходы на её поддержание в ситуации без отказов и с ними. Кроме того, нагрузка на узлы (в плане числа обрабатываемых сообщений) должна распределяться равномерно - отношение max/min нагрузки по всем узлам не должно превышать 5.

Если вам плохо понятны некоторые требования, изучите соответствующие тесты - это часть условия задачи.

## Реализация

Для реализации и тестирования решения используется фреймворк dslib (см. материалы первого семинара).

В папке задачи размещена заготовка для решения [solution.py](solution.py). Вам надо доработать реализацию узла в классе `GroupMember` так, чтобы проходили все тесты.

При инициализации узлу передается его уникальный _id_. Узел должен поддерживать обработку следующих локальных сообщений:
- _JOIN_ - команда присоединиться к группе. В результате обработки этой команды узел должен стать участником группы. В поле `seed` передается идентификатор одного из живых участников группы. Если в `seed` находится идентификатор самого узла, то он должен создать новую пустую группу и добавить в неё себя. Ответ на это сообщение не нужен.
- _LEAVE_ - команда покинуть группу. В результате обработки этой команды узел должен перестать быть участником группы. Ответ на это сообщение не нужен.
- _GET_MEMBERS_ - запрос списка участников группы. В ответ на запрос узел должен отправить локальное сообщение _MEMBERS_ со списком идентификаторов узлов, входящих сейчас в группу (см. заготовку).

Для взаимодействия между узлами вы можете использовать любые собственные типы сообщений.

**Важно!** Для измерения прошедшего времени в коде узла используйте метод `ctx.time()`, возвращающий локальное время "внутри симуляции". Использовать обычные способы, например `time.time()`, некорректно, так как скорость течения времени в симуляции отличается от реального времени. Также не стоит опираться на синхронизацию часов в системе - у каждого узла свои локальные часы, и показания `ctx.time()` на разных узлах могут расходиться.

В коде узла можно использовать генератор случайных чисел из `random`, но не следует его явно инициализировать с помощью `random.seed()`. Это уже делается в dslib на основе переданного в тесты seed, а дополнительная инициализация может нарушить воспроизводимость результатов.

## Тестирование

Перед запуском тестов убедитесь, что на вашей машине [установлен Rust](https://www.rust-lang.org/tools/install) (версия не ниже 1.62).

Тесты находятся в папке `test`. Для запуска тестов перейдите в эту папку и выполните команду: `cargo run --release`. Запустить только один из тестов можно с помощью опции `-t` (например, `cargo run --release -- -t "NODE CRASH"`). По умолчанию вывод тестов не содержит трассы (последовательности событий во время выполнения каждого из тестов), а только финальную сводку. Включить вывод трасс можно с помощью флага `-d`. Все доступные опции можно посмотреть с помощью `cargo run --release -- --help`. Часть из них уже должна быть вам знакома по прошлым задачам. Число тестов `CHAOS MONKEY` в GitLab CI увеличено до 1000: `cargo run --release --m 1000`.

Также можно воспользоваться подготовленным [Docker-образом](Dockerfile) (в нём же тесты запускаются в GitLab CI). Работа с образом полностью аналогична тому, как это описано в первой задаче.

Если вы найдете ошибки или требования из условий, которые не покрывают наши тесты, то вы можете получить за это бонусы. Для этого надо включить в отчёт описание ситуации, которую не ловят тесты, добавив при необходимости пример решения с ошибкой. За это полагается 0.5 балла. Если вы также реализуете тесты, которые ловят найденную проблему, или хотя бы опишите их логику, то получите еще 0.5 балла. Готовые тесты оформляйте как merge request в родительский репозиторий с заданиями.

## Оценивание

Эта задача учитывается как 1.5 обычных, то есть максимум можно набрать 15 баллов.

Компоненты задачи и их вклад в оценку:
- Отчёт с описанием вашего решения в файле `solution.md` - обязательно, без него проверка производиться не будет.
- Базовый функционал без обработки отказов (тесты: SIMPLE, RANDOM SEED, NODE JOIN, NODE LEAVE) - 4 балла.
- Обработка отказов узлов (тесты "NODE CRASH" в названии) - 3 балла.
- Обработка отказов сети (остальные тесты кроме "SCALABILITY...") - 3 балла.
- Масштабируемость при росте числа узлов (тесты "SCALABILITY...") - 5 баллов.

## Сдача

Следуйте стандартному [порядку сдачи заданий](../README.md).
