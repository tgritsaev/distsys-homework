
OVERHEAD-оптимизации 3-4 я не довел до конца.

1. Храню принятые id-шники, можно воспользоваться сетом, можно создать массив определенного размера. 
OVERHEAD оптимизации:
Я пользовался сетом, так же ставил timer на очищение сета.     
2. Отправляю сообщение к серверу, ставлю таймер на перепосылку. При срабатывании таймера отправляю сообщение еще раз. От сервера отправляю сообщение клиенту, что сервер принял сообщение. Если клиент принимает сообщение, удаляю таймер на посылку сообщения и удаляю сообщения из словаря.
OVERHEAD оптимизации:
Сперва нужно было пройти traffic-ограничение, для этого я передавал в обратном сообщении только информацию об id.
Ну и чистил все хранилища сообщений как в прошлом тесте. 

На тесте 3 я перестал делать OVERHEAD-оптимизации, можно не читать.

3. Код Sender-а я скопировал до OVERHEAD-оптимизаций. В Receiver добавил множество для хранения уже полученных сообщений и проверяем, что в нем не лежит сообщение. 
OVERHEAD оптимизации: 
3.1. Самым простым решением является не чистить множество полученных сообщений в Receiver-e. Но так мы не пройдем тест на память, поэтому реализуем механизм отклика, что Sender убедился в доставленности сообщения, после чего Receiver может удалить из своего хранилища уже ненужный id.
3.2. Теперь возникает проблема оптимизации по памяти Sender, причем я уже очищаю хранилища Sender-a. Теперь я стал хранить в хранилище Sender-a не сообщения полностью, а только текст сообщения и на месте собирать Message для отправки.
После этого получил такой вердикт: 
--- [EXACTLY ONCE] OVERHEAD NORMAL ---

100    Send Mem: 2152     Recv Mem: 1591     Messages: 300      Traffic: 12590

FAILED: Sender memory > 2000


--- [EXACTLY ONCE] OVERHEAD FAULTY ---

100    Send Mem: 12383    Recv Mem: 3903     Messages: 620      Traffic: 26298

FAILED: Receiver memory > 2000

3.3. Меняю dict в Receiver на [].
Получаю: 
--- [EXACTLY ONCE] OVERHEAD NORMAL ---

100    Send Mem: 2152     Recv Mem: 659      Messages: 300      Traffic: 12590

FAILED: Sender memory > 2000


--- [EXACTLY ONCE] OVERHEAD FAULTY ---

100    Send Mem: 12383    Recv Mem: 2103     Messages: 620      Traffic: 26298

FAILED: Receiver memory > 2000

И ловим адский кринж, двигаемся дальше. 

3.4. Тогда по аналогии попробуем заменить dict в Sender-е на []. На удивление это только увеличило потребление памяти Sender-a, поэтому от этой идеи отказываемся.


4. Скопировал код 3 до OVERHEAD-оптимизаций. Для строгого упорядочивания я сохраняю сообщения и посылаю запрос от Receiver-а к Sender с целью узнать первый id, про который Sender не уверен об успешности доставки. Значит, все сообщения с меньшим id можно отправить уже от Receiver-а в самый конечный узел, посылаем этот id к Receiver-у.  
