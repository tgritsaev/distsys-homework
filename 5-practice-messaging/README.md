# Практика с RabbitMQ

## Описание

В рамках данного домашнего задания вы научитесь работать с брокером сообщений RabbitMQ. Вам предлагается реализовать сервис для генерации описания к изображениям. Пользователь может загрузить изображение, после чего ваш сервис должен будет сгенерировать описание к изображению, сохранить результат обработки в файл и вернуть описание пользователю при запросе.


### Архитектура сервиса

Обычно Message Queue используется для того, чтобы избежать немедленного выполнения ресурсоемкой задачи, без необходимости ждать ее завершения. Вместо этого мы планируем выполнить задачу позже. Например, данный паттерн часто применяется для работы с видео. В нашем примере все еще можно было использовать прямое взаимодействие между REST API сервисом и сервисом генерации описаний, но использование Message Queue дает такие преимущества, как обработка отказов, если один из воркеров вдруг упадет, то сообщение не потеряется, а будет обработано другим воркером. Еще одним преимуществом использования очереди сообщений для коммуникации между сервисами является возможность масштабировать число обработчиков горизонтально в зависимости от нагрузки. Мы будем использовать следующую архитектуру для нашего сервиса:

![Architecture](media/architecture.png)


1. REST API сервис принимает запросы от пользователя и отправлет их в очередь RabbitMQ
2. Воркеры забирают сообщения из очереди, обрабатывают их и сохраняют в docker volume (см. docker-compose.yml)


### Интерфейс сервиса
```
POST /images
Отправляет изображение на сервер

Body:
{
    "image_url": "shorturl.at/notNY",
}

Response:
{
    "image_id": int
}
```

```
GET /images
Возвращает id всех обработанных изображений

Response:
{
    "image_ids": List[int]
}
```

```
GET /images/<image_id>
Возвращает описание для данного изображения, если оно уже было обработано, в противном случае возвращает код 404

Response:
{
    "description": str
}
```


### Описание шаблона
Присутствуют следующие папки:
- `server` - папка, содержащая код REST API сервиса 
- `worker` - папка, содержащая код логики обработки изображений
- `tests` - папка с тестами 

### Оценивание
1. (3 балла) Реализована логика отправки сообщения в RabbitMQ
2. (2 балла) Реализована логика обработки сообщения из RabbitMQ
3. (1 балл) Реализована логика отправки обработанных id пользователю
4. (2 балла) Реализована логика отправки результатов пользователю
5. (2 балла) Реализована логика обработки отказов для publisher

## В каком порядке делать?
1. Реализуйте логику обработки запроса и отправки сообщения в очередь `add_image` в server/server.py

2. Реализуйте логику обработки сообщений в worker/worker.py. Ваша реализация должна поддерживать обработку отказов, в случае, если воркер упадет. Код для генерации описания к изображению лежит в worker/caption.py.

3. Добавьте сохранение результата обработки, его можно сохранять в обычный файл '{image_id}.txt'

4. Реализуйте метод `get_image_ids` в server/server.py

5. Реализуйте метод `get_processing_result` в server/server.py.

6. Изучите концепцию publisher confirms и реализуйте обработку отказов для publisher. Ваше решение должно обрабатывать почти все сообщения, которые были получены сервером, даже в случае если сервер в какой-то момент упадет. Почти все в данном контексте значит, что может пройти некоторое время между получением и сохранением сообщения на диск.

7. При необходимости поправьте Dockerfile и docker-compose.yml файлы для своей конфигурации

8. Проверьте локально, что ваши тесты проходят

9. Откройте Merge Request в своём приватном репозитории и дождитесь, что тесты зелёные

## Запуск заготовок и тестов

Соберите все свои сервисы:
```
docker-compose build
```

Запустите RabbitMQ, сервер и воркеры:
```
docker-compose up --scale worker=2 rabbitmq web worker
```

После можете запустить тесты в отдельном окне:
```
docker-compose run pytest
```
